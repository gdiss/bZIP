---
title: "20231002_StrongBinderTest_DataAnalysis_3571R"
author: "Alexandra Bendel"
date: "`r Sys.Date()`"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Introduction:
I conducted a small-scale deepPCA using the predicted strong binders from Bastian.
This is the data analysis.


```{r - Libraries, wd etc.}
suppressPackageStartupMessages({
  library(parallel)
  library(mutscan)
  library(stringdist)
  library(stringr)
  library(ShortRead)
  library(dplyr)
  library(ggplot2)
  library(cowplot)
  library(gridExtra)
  library(ggh4x)
})

```



The amplicon has the following structure:

RE - bar - RE - WT bar

6  - 22  - 6  -   7   


We look for the perfect position of the restriction sites so that the bc is always 22bp, which represent the vast majority of them anyway, and so that we can collapse barcode reads

To speed up the process, we don't look for a match of the constant sequences, we just skip them. Anyway, these are restriction sites and the cloning wouldn't have worked if there was a mutation. It could allow to filter-out weird reads, but since we're looking for perfect barcode matches, we don't care because if the two barcodes matches expected one, it's not coincidence

```{r - Digest FastQs}

# sample names
datapath = "000-data"

samples <- dir(datapath)[grep("3571F",dir(datapath))]
samples = samples[grep(".fastq.gz",samples)]

names(samples) <- c("IN1", "IN2", "IN3", "IN4", 
                    "OUT1", "OUT2", "OUT3", "OUT4")

samples_l <- list("IN1" = samples[1],
                  "IN2" = samples[2], 
                  "IN3" = samples[3], 
                  "IN4" = samples[4],
                  "OUT1" = samples[5], 
                  "OUT2" = samples[6], 
                  "OUT3" = samples[7], 
                  "OUT4" = samples[8]
                  )

lapply(1:length(samples_l),function(x){
  
  sample_subset = samples_l[[x]]
  
  raw = digestFastqs(
            fastqForward = paste0(datapath, sample_subset), 
            elementsForward = "SVSVS",
            elementLengthsForward = c(6, 22, 6, 7, -1),
            avePhredMinForward = 20,
            maxNReads = -1, 
            nThreads = 48,
            verbose = F
            )
        
        
  save(raw, file=paste("006-digestedFastqs/no_collapse_sample_",x))
  
})


```

## Barcodes:
```{r - Barcodes}


# wt barcodes
wt_bar = read.csv("000-data/TableS9_wt_preys_gblocks_and_barcodes.txt")

# wt AA sequence
wt_seq = read.delim("000-data/TableS6_wt_bZIPs_aa_seq.txt")
tmp = wt_seq$Gene
wt_seq = wt_seq$bZIP_aa
names(wt_seq) = tmp

# wt nt sequence for preys
wt_nt_seq = read.csv("000-data/TableS9_wt_preys_gblocks_and_barcodes.txt")
wt_nt_seq$seq = substr(wt_nt_seq$seq,983,1500)
str_sub(wt_nt_seq$seq,-6,-1) = ""
tmp = wt_nt_seq$bZIP
wt_nt_seq = wt_nt_seq$seq
names(wt_nt_seq) = tmp


## New baits:
baits <- read.csv("000-data/TableS12_synthetic_bZIPs_oligo_library.csv")
bait_bar <- select(baits, Name, barcode)

## Barcodes need to be reverse complement
reverse_complement <- function(dna_string) {
  # Create a character vector to store the complemented bases
  complemented_bases <- character(0)
  
  # Define a mapping of complementary bases
  base_map <- c("A" = "T", "T" = "A", "C" = "G", "G" = "C")
  
  # Reverse the input DNA string and complement the bases
  for (base in rev(strsplit(dna_string, NULL)[[1]])) {
    complemented_bases <- c(complemented_bases, base_map[base])
  }
  
  # Concatenate the complemented bases to form the reverse complement
  reverse_complement_string <- paste(complemented_bases, collapse = "")
  
  return(reverse_complement_string)
}

for(i in 1:nrow(bait_bar)){
  bait_bar$rev_bar[i] <- reverse_complement(bait_bar$barcode[i])
}



```

Directly filter out reads that don't perfectly match expected barcodes

```{r - Collapse barcodes, summarized exp etc}
raw1 <- list()

for (i in 1:8){
  
  cat("\r",i,"\t\t")
  
  load(paste0("006-digestedFastqs/no_collapse_sample_ ",i))

  raw1[[i]] = raw}
  
head(raw1[[6]]$summaryTable)

raw2 <- list()
for (i in 1:8){
  
  cat("\r",i,"\t\t")
  
  load(paste0("006-digestedFastqs/no_collapse_sample_ ",i))
  
  cat("loaded\t\t")
  
  bc_bait = substr(raw$summaryTable$sequence,1,22)
  bc_wt = substr(raw$summaryTable$sequence,23,29)
  
  raw$summaryTable = raw$summaryTable[bc_bait %in% bait_bar$rev_bar & bc_wt %in% wt_bar$bar,]
  
  cat("filtered\t\t")

  raw2[[i]] = raw
  
}
names(raw2) = names(samples_l)



raw3 <- list(IN1 = raw2$IN1$summaryTable,
             IN2 = raw2$IN1$summaryTable,
             IN3 = raw2$IN2$summaryTable,
             IN4 = raw2$IN3$summaryTable,
             OUT1 = raw2$OUT1$summaryTable,
             OUT2 = raw2$OUT2$summaryTable,
             OUT3 = raw2$OUT3$summaryTable,
             OUT4 = raw2$OUT4$summaryTable )

             
raw3 <- lapply(raw3, function(x) {
  selected_columns <- dplyr::select(x, sequence, nbrReads)
  return(selected_columns)
})           
          
head(raw3$IN1)


   
m <- full_join(raw3$IN1, raw3$IN2, by="sequence")
m <- full_join(m, raw3$IN3, by="sequence")
m <- full_join(m, raw3$IN4, by="sequence")
m <- full_join(m, raw3$OUT1, by="sequence")
m <- full_join(m, raw3$OUT2, by="sequence")
m <- full_join(m, raw3$OUT3, by="sequence")
m <- full_join(m, raw3$OUT4, by="sequence")

colnames(m) <- c("sequence", "IN1", "IN2", "IN3", "IN4", "OUT1", "OUT2", "OUT3", "OUT4")
m_m <- as.matrix(m[,c(2:9)])
colnames(m_m) <- c("IN1", "IN2", "IN3", "IN4", "OUT1", "OUT2", "OUT3", "OUT4")
rownames(m_m) <- m$sequence             
 
## NAs must be 0:
m_m[is.na(m_m)] <- 0


colData <- data.frame(sample = c( "IN1", "IN2", "IN3", "IN4", "OUT1", "OUT2", "OUT3", "OUT4"), 
                      condition = c("INPUT", "INPUT", "INPUT", "INPUT", "OUTPUT", "OUTPUT", "OUTPUT", "OUTPUT"), 
                      replicate = c("1", "2", "3", "4", "1", "2", "3", "4")) 
rowData <- rownames(m_m)

            
se <- SummarizedExperiment(assays = list(counts = m_m), colData = colData, rowData = rowData)

## Look at the model matrix:
model.matrix(~ replicate + condition, data = colData(se))

## We want to use conditionOUTPUT as coefficient. 
lfc <- calculateRelativeFC(
  se = se,
  design = model.matrix(~ replicate + condition,
                        data = colData(se)),
  coef = "conditionOUTPUT", pseudocount = 1, method = "limma"
)
             
hist(lfc$logFC)
## Histogram looks good.

```


## Add names:
```{r - Add names}
lfc$sequence <- rownames(lfc)
lfc$bait_bc <- str_sub(rownames(lfc), 1, 22)
lfc$prey_bc <- str_sub(rownames(lfc), 23, 29)

lfc <- right_join(lfc, bait_bar, by = c("bait_bc" = "rev_bar"))
lfc <- right_join(lfc, wt_bar, by = c("prey_bc" = "barcode"))

colnames(lfc)[15] <- "bait"
colnames(lfc)[17] <- "prey"

head(lfc)


## Add counts to filter out low ones.
counts <- Reduce(function(x, y) merge(x, y, by = "sequence", all = TRUE), raw3)
colnames(counts) <- c("sequence", "i1", "i2", "i3", "i4", "o1", "o2", "o3", "o4")


lfc <- full_join(lfc, counts, by = "sequence")

lfc <- filter(lfc, i1 > 10 & i2 > 10 & i3 > 10 & i4 > 10 & o1 > 0 & o2 > 0 & o3 > 0 & o4 > 0 )

lfc = lfc[,c(15,17,20:27,1:11)]

save(lfc,file="006-synthetic_bZIPs_binding_scores.Rdata")
```


